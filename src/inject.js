var maxResultsPerPage = 10;

var searchUrl = query => `https://www.google.com/search?q=site:quizlet.com ${query}&num=${maxResultsPerPage}`;
var searchStrictUrl = query => `https://www.google.com/search?q=site:quizlet.com "${query}"&num=${maxResultsPerPage}`;

var flatten = arr => [].concat(...arr);
var toTenths = num => Math.round(num * 10) / 10;

var mcRegex = /^(\w[\)>\]}:\.])(.*)$/i;
var tfRegex = /^(true|false|t|f)$/i;

var isMC = ans => mcRegex.test(ans);
var isTF = ans => tfRegex.test(ans);

var isNumber = num => !isNaN(Number(num))

var VERIFY_ERROR_MSG = 'Verification required!';

var MIN_SCIENTIFIC_ANSWERS = 5;
var MAX_SCIENTIFIC_ANSWERS = 15;
var MAX_COMMON_ANSWERS = 60;

//Fetch From the Background
function fetchResource(input, init) {
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage({input, init}, messageResponse => {
      const [response, error] = messageResponse;
      if (response === null) {
        reject(error);
      } else {
        // Use undefined on a 204 - No Content
        const body = response.body ? new Blob([response.body]) : undefined;
        resolve(new Response(body, {
          status: response.status,
          statusText: response.statusText,
        }));
      }
    });
  });
}



function getCleanBool(raw) {
  var cleaned = raw.toLowerCase();
  if (cleaned == 't') cleaned = 'true';
  if (cleaned == 'f') cleaned = 'false';
  return cleaned;
}

function parse2DOM(html) {
  var parser = new DOMParser();
  return parser.parseFromString(html, 'text/html')
}

function getSearchLinks(data) {
  var items = [...parse2DOM(data).querySelectorAll('div.g')]
  var links = items.map(item => item.querySelector('div.r > a').href)
  return links;
}

// sometimes, Google will think that the searches are generated by a bot and will occasionally
// ask for you to verify yourself, in which this plugin will do that for you
function verifySelfToGoogle(res) {
  alert("Google needs to check if you are a robot or not! I will open a new link to let you do the verification.");
  window.open(res.url);
  throw new Error(VERIFY_ERROR_MSG);
}

function parseQuizletPage(data) {
  var package = [];

  var cardPairs = [...parse2DOM(data).getElementsByClassName('SetPageTerm')]
  cardPairs.forEach(cardPair => {
    var _word = cardPair.getElementsByClassName('SetPageTerm-wordText')[0].innerText.trim();
    var _definition = cardPair.getElementsByClassName('SetPageTerm-definitionText')[0].innerText.trim();

    // used for always putting the shorter text into the answer field
    // 'proper' order: 'wordText' is shorter (or equal to) than 'definitionText'
    var isProperOrder = _word.length <= _definition.length;
    var question = isProperOrder ? _definition : _word;
    var answer = isProperOrder ? _word : _definition;

    // no elipses allowed!
    if (answer == '...')
      return;

    // processing multiple choice inputs
    if (question.includes('\n')) { // the question probably has a set of multiple choice answers
      var questionParts = question.split('\n');
      // we need to get a list of possible answers while not getting any false positives
      var rawAnswers = questionParts.slice(1);
      var possibleAnswers = rawAnswers
        .map(ans => ans.trim())
        .filter(ans => ans.length > 0)
        .filter(ans => isMC(ans) || isTF(ans));

      // if there's at least 2 valid choices, we probably
      if (possibleAnswers.length >= 2) {
        // set the part before the start of newlines to be the REAL question
        question = questionParts[0];

        var multipleChoice = possibleAnswers.filter(ans => isMC(ans));
        var binaryChoice = possibleAnswers.filter(ans => isTF(ans));

        // check for multiple choice answers
        if (multipleChoice.length > 0) {
          // process the possible answers
          var correctLetter = answer.toLowerCase()[0];
          for (var ans of possibleAnswers) {
            var results = mcRegex.exec(ans)
            var letter = results[1].toLowerCase()[0]
            var value = results[2].trim()

            // find the correct answer
            if (letter === correctLetter) {
              answer = value;
              break;
            }
          }
        }
        // check for true/false answers
        else if (binaryChoice.length > 0)
          answer = getCleanBool(answer);
        else {
          // this shouldn't happen, because and supposedly invalid answers would have been filtered out already
          console.log("This shouldn't be happening!");
        }
      }
    }

    // sometimes the 'answer' itself will have the 'A)' format, despite there being no multiple choice
    if (isMC(answer))
      answer = mcRegex.exec(answer)[2].trim()

    // having 'T' or 'F' isn't an informative answer
    if (isTF(answer))
      answer = getCleanBool(answer);

    package.push({ question, answer });
  })

  return package;
}

function fuseSearch(query, list, thresh) {
  var options = {
    shouldSort: true,
    tokenize: true,
    matchAllTokens: true,
    includeScore: true,
    threshold: thresh,
    distance: 100,
    location: 0,
    maxPatternLength: 256,
    minMatchCharLength: 1,
    keys: [ 'question' ]
  }

  var fuse = new Fuse(list, options);
  var result = fuse.search(query);
  return result;
}

/*
 * The algorithm works to mazimize the possibilities of truthy answers while also reducing the relevance
 * of rare answers. It'll iterative perform a fuzzy search with a threshold of 0.0 (lower is better) and
 * work its way down to 0.6, which is the default threshold for fuse.js.
 *
 * There's also a trust hierarchy between the thresholds, similar to scientists (0.0) vs common people (0.6).
 * In order for a truthy answer to be determined, there has to be a minimum of 10 sciencists that have an answer,
 * and there can be no more than 60 answers from the common people added at any time. Additionally, if there's
 * more than 15 scientists with an answer, that will be enough to determine an answer as well.
 */
function greedyHierarchicalFuzzySearch(query, list) {
  var totalResults = [];
  var trusted = [0, 1, 2];
  var midlyTrusted = [3, 4];
  var notTrusted = [5, 6];
  var countedResults = 0;
  for (var thresh = 0; thresh <= 6; thresh++) {
    var subResults = fuseSearch(query, list, thresh / 10);

    var projectedCount = countedResults + subResults.length;

    // there's a lot of scientific answers in the pool, which is enough to determine a solid answer
    if (countedResults >= MAX_SCIENTIFIC_ANSWERS && midlyTrusted.includes(thresh))
      break;

    // we don't have a lot of scientific results, thus we can safely assume that the rest aren't worth trusting
    if (projectedCount < MIN_SCIENTIFIC_ANSWERS && notTrusted.includes(thresh))
      continue;

    // we start getting quite a bit of irrelevant common answers so let's ignore it
    if (subResults.length > MAX_COMMON_ANSWERS)
      continue;

    totalResults.push(subResults);
    countedResults += subResults.length;
  }

  return flatten(totalResults);
}

// Strat: group similar answers to each other and count their frequencies
// Highest frequency => most probable answer
function mostLikelyAnswer(answers) {
  // the background page will handle this logic
  if (answers.length == 0)
    return null;

  if (answers.length == 1)
    return answers[0];

  var uniqueAnswers = Array.from(new Set(answers));
  var modeMap = {};

  for (var uniqAns of uniqueAnswers)
    modeMap[uniqAns] = answers.filter(ans => ans == uniqAns).length;

  // most frequent item is on top, hence we do 'b - a'
  var sortedAnswers = Object.keys(modeMap).sort((a,b) => modeMap[b] - modeMap[a]);
  return sortedAnswers[0];
}

var debugOutput = stuff => { console.log(stuff); return stuff; };
var debugJsonOutput = stuff => { console.log(JSON.stringify(stuff, null, 2)); return stuff; };

function searchDefinitions(query, callback) {
  fetchResource(searchStrictUrl(query))
    // get google search page data
    .then(res => res.ok ? res.text().then(getSearchLinks) : verifySelfToGoogle(res))
    // get quizlet link for each google result and fetch it
    .then(searchLinks => searchLinks.map(link => fetchResource(link)))
    .then(promises => Promise.all(promises))
    // filter the ones that return a non-200 response (mainly to filter unauthorized access problems)
    .then(resArr => resArr.filter(res => res.ok))
    // get the HTML from each of the pages
    .then(filteredResArr => filteredResArr.map(res => res.text()))
    .then(promises => Promise.all(promises))
    // retrieve question -> answer values as super array
    .then(datas => flatten(datas.map(parseQuizletPage)))
    // fuzzy search against the given query
    .then(quizletResults => greedyHierarchicalFuzzySearch(query, quizletResults))
    // retrieve only the answers from the final results
    .then(finalResults => finalResults.map(res => res.item.answer))
    // make all answers lowercase and striped, and remove single letter responses (used for cleaning answer data)
    .then(rawAnswers => rawAnswers.map(ans => ans.toLowerCase()))
    .then(rawAnswers => rawAnswers.map(ans => ans.trim()))
    .then(rawAnswers => rawAnswers.filter(ans => isNumber(ans) || ans.length > 1))
    // find the most likely answer by merging common ones and comparing its frequencies
    .then(possibleAnswers => mostLikelyAnswer(possibleAnswers))
    // return the first answer back to the background page
    .then(finalAnswer => callback({ success: finalAnswer }))
    .catch(err => {
      if (err.message === VERIFY_ERROR_MSG)
        callback({ verifyRequired: true });
      else
        callback({ error: err.message });
    });
}

chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
  if (msg.text === 'report_back' && typeof msg.query !== "undefined")
    searchDefinitions(msg.query, sendResponse);
  return true;
});
